// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_INCLUDED_protocol_2eproto
#define PROTOBUF_INCLUDED_protocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2eproto 

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_protocol_2eproto
namespace fileprotocol {
class AuthRequest;
class AuthRequestDefaultTypeInternal;
extern AuthRequestDefaultTypeInternal _AuthRequest_default_instance_;
class AuthResponse;
class AuthResponseDefaultTypeInternal;
extern AuthResponseDefaultTypeInternal _AuthResponse_default_instance_;
class BrowseResponse;
class BrowseResponseDefaultTypeInternal;
extern BrowseResponseDefaultTypeInternal _BrowseResponse_default_instance_;
class FileDownloadRequest;
class FileDownloadRequestDefaultTypeInternal;
extern FileDownloadRequestDefaultTypeInternal _FileDownloadRequest_default_instance_;
class FileSummary;
class FileSummaryDefaultTypeInternal;
extern FileSummaryDefaultTypeInternal _FileSummary_default_instance_;
class FileTransfer;
class FileTransferDefaultTypeInternal;
extern FileTransferDefaultTypeInternal _FileTransfer_default_instance_;
class MsgBody;
class MsgBodyDefaultTypeInternal;
extern MsgBodyDefaultTypeInternal _MsgBody_default_instance_;
class MsgHeader;
class MsgHeaderDefaultTypeInternal;
extern MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
class StatusUpdate;
class StatusUpdateDefaultTypeInternal;
extern StatusUpdateDefaultTypeInternal _StatusUpdate_default_instance_;
}  // namespace fileprotocol
namespace google {
namespace protobuf {
template<> ::fileprotocol::AuthRequest* Arena::CreateMaybeMessage<::fileprotocol::AuthRequest>(Arena*);
template<> ::fileprotocol::AuthResponse* Arena::CreateMaybeMessage<::fileprotocol::AuthResponse>(Arena*);
template<> ::fileprotocol::BrowseResponse* Arena::CreateMaybeMessage<::fileprotocol::BrowseResponse>(Arena*);
template<> ::fileprotocol::FileDownloadRequest* Arena::CreateMaybeMessage<::fileprotocol::FileDownloadRequest>(Arena*);
template<> ::fileprotocol::FileSummary* Arena::CreateMaybeMessage<::fileprotocol::FileSummary>(Arena*);
template<> ::fileprotocol::FileTransfer* Arena::CreateMaybeMessage<::fileprotocol::FileTransfer>(Arena*);
template<> ::fileprotocol::MsgBody* Arena::CreateMaybeMessage<::fileprotocol::MsgBody>(Arena*);
template<> ::fileprotocol::MsgHeader* Arena::CreateMaybeMessage<::fileprotocol::MsgHeader>(Arena*);
template<> ::fileprotocol::StatusUpdate* Arena::CreateMaybeMessage<::fileprotocol::StatusUpdate>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace fileprotocol {

enum Status {
  TRANSFERRING = 0,
  PAUSE = 1,
  END = 2,
  DONE = 3,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Status_IsValid(int value);
const Status Status_MIN = TRANSFERRING;
const Status Status_MAX = DONE;
const int Status_ARRAYSIZE = Status_MAX + 1;

enum MsgType {
  BROWSE_REQUEST = 0,
  BROWSE_RESPONSE = 1,
  FILE_UPLOAD_REQUEST = 2,
  FILE_DOWNLOAD_REQUEST = 3,
  FILE_DOWNLOAD_RESPONSE = 4,
  FILE_TRANSFER = 5,
  STATUS_UPDATE = 6,
  ACK = 7,
  PING = 8,
  PONG = 9,
  AUTH_REQUEST = 10,
  AUTH_RESPONSE = 11,
  CLOSE = 12,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = BROWSE_REQUEST;
const MsgType MsgType_MAX = CLOSE;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

enum AuthRequestState {
  LOGIN = 0,
  REGISTER = 1,
  LOGINOUT = 2,
  AuthRequestState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AuthRequestState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AuthRequestState_IsValid(int value);
const AuthRequestState AuthRequestState_MIN = LOGIN;
const AuthRequestState AuthRequestState_MAX = LOGINOUT;
const int AuthRequestState_ARRAYSIZE = AuthRequestState_MAX + 1;

enum AuthResponseState {
  LOGIN_SUCCESS = 0,
  REGISTER_SUCCESS = 1,
  LOGOUT_SUCCESS = 2,
  PASSWD_ERROR = 3,
  USER_NOT_EXIT = 4,
  USER_ALEADY_EXIT = 5,
  UNKNOW_ERROR = 6,
  AuthResponseState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AuthResponseState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AuthResponseState_IsValid(int value);
const AuthResponseState AuthResponseState_MIN = LOGIN_SUCCESS;
const AuthResponseState AuthResponseState_MAX = UNKNOW_ERROR;
const int AuthResponseState_ARRAYSIZE = AuthResponseState_MAX + 1;

// ===================================================================

class AuthRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.AuthRequest) */ {
 public:
  AuthRequest();
  virtual ~AuthRequest();

  AuthRequest(const AuthRequest& from);

  inline AuthRequest& operator=(const AuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthRequest(AuthRequest&& from) noexcept
    : AuthRequest() {
    *this = ::std::move(from);
  }

  inline AuthRequest& operator=(AuthRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AuthRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRequest*>(
               &_AuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AuthRequest* other);
  friend void swap(AuthRequest& a, AuthRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthRequest* New() const final {
    return CreateMaybeMessage<AuthRequest>(NULL);
  }

  AuthRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AuthRequest& from);
  void MergeFrom(const AuthRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string passwd = 3;
  void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  const ::std::string& passwd() const;
  void set_passwd(const ::std::string& value);
  #if LANG_CXX11
  void set_passwd(::std::string&& value);
  #endif
  void set_passwd(const char* value);
  void set_passwd(const char* value, size_t size);
  ::std::string* mutable_passwd();
  ::std::string* release_passwd();
  void set_allocated_passwd(::std::string* passwd);

  // .fileprotocol.AuthRequestState auth_request_state = 1;
  void clear_auth_request_state();
  static const int kAuthRequestStateFieldNumber = 1;
  ::fileprotocol::AuthRequestState auth_request_state() const;
  void set_auth_request_state(::fileprotocol::AuthRequestState value);

  // @@protoc_insertion_point(class_scope:fileprotocol.AuthRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr passwd_;
  int auth_request_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.AuthResponse) */ {
 public:
  AuthResponse();
  virtual ~AuthResponse();

  AuthResponse(const AuthResponse& from);

  inline AuthResponse& operator=(const AuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthResponse(AuthResponse&& from) noexcept
    : AuthResponse() {
    *this = ::std::move(from);
  }

  inline AuthResponse& operator=(AuthResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AuthResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthResponse* internal_default_instance() {
    return reinterpret_cast<const AuthResponse*>(
               &_AuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AuthResponse* other);
  friend void swap(AuthResponse& a, AuthResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthResponse* New() const final {
    return CreateMaybeMessage<AuthResponse>(NULL);
  }

  AuthResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AuthResponse& from);
  void MergeFrom(const AuthResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fileprotocol.AuthResponseState auth_response_state = 1;
  void clear_auth_response_state();
  static const int kAuthResponseStateFieldNumber = 1;
  ::fileprotocol::AuthResponseState auth_response_state() const;
  void set_auth_response_state(::fileprotocol::AuthResponseState value);

  // @@protoc_insertion_point(class_scope:fileprotocol.AuthResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int auth_response_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BrowseResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.BrowseResponse) */ {
 public:
  BrowseResponse();
  virtual ~BrowseResponse();

  BrowseResponse(const BrowseResponse& from);

  inline BrowseResponse& operator=(const BrowseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BrowseResponse(BrowseResponse&& from) noexcept
    : BrowseResponse() {
    *this = ::std::move(from);
  }

  inline BrowseResponse& operator=(BrowseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BrowseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrowseResponse* internal_default_instance() {
    return reinterpret_cast<const BrowseResponse*>(
               &_BrowseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BrowseResponse* other);
  friend void swap(BrowseResponse& a, BrowseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BrowseResponse* New() const final {
    return CreateMaybeMessage<BrowseResponse>(NULL);
  }

  BrowseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BrowseResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BrowseResponse& from);
  void MergeFrom(const BrowseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrowseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string filenames = 1;
  int filenames_size() const;
  void clear_filenames();
  static const int kFilenamesFieldNumber = 1;
  const ::std::string& filenames(int index) const;
  ::std::string* mutable_filenames(int index);
  void set_filenames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filenames(int index, ::std::string&& value);
  #endif
  void set_filenames(int index, const char* value);
  void set_filenames(int index, const char* value, size_t size);
  ::std::string* add_filenames();
  void add_filenames(const ::std::string& value);
  #if LANG_CXX11
  void add_filenames(::std::string&& value);
  #endif
  void add_filenames(const char* value);
  void add_filenames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filenames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filenames();

  // @@protoc_insertion_point(class_scope:fileprotocol.BrowseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filenames_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileSummary : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.FileSummary) */ {
 public:
  FileSummary();
  virtual ~FileSummary();

  FileSummary(const FileSummary& from);

  inline FileSummary& operator=(const FileSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileSummary(FileSummary&& from) noexcept
    : FileSummary() {
    *this = ::std::move(from);
  }

  inline FileSummary& operator=(FileSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const FileSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileSummary* internal_default_instance() {
    return reinterpret_cast<const FileSummary*>(
               &_FileSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FileSummary* other);
  friend void swap(FileSummary& a, FileSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileSummary* New() const final {
    return CreateMaybeMessage<FileSummary>(NULL);
  }

  FileSummary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileSummary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FileSummary& from);
  void MergeFrom(const FileSummary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // string format = 2;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // string filehash = 3;
  void clear_filehash();
  static const int kFilehashFieldNumber = 3;
  const ::std::string& filehash() const;
  void set_filehash(const ::std::string& value);
  #if LANG_CXX11
  void set_filehash(::std::string&& value);
  #endif
  void set_filehash(const char* value);
  void set_filehash(const char* value, size_t size);
  ::std::string* mutable_filehash();
  ::std::string* release_filehash();
  void set_allocated_filehash(::std::string* filehash);

  // fixed64 filesize = 4;
  void clear_filesize();
  static const int kFilesizeFieldNumber = 4;
  ::google::protobuf::uint64 filesize() const;
  void set_filesize(::google::protobuf::uint64 value);

  // fixed32 total_chunk = 5;
  void clear_total_chunk();
  static const int kTotalChunkFieldNumber = 5;
  ::google::protobuf::uint32 total_chunk() const;
  void set_total_chunk(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fileprotocol.FileSummary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::google::protobuf::internal::ArenaStringPtr filehash_;
  ::google::protobuf::uint64 filesize_;
  ::google::protobuf::uint32 total_chunk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileDownloadRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.FileDownloadRequest) */ {
 public:
  FileDownloadRequest();
  virtual ~FileDownloadRequest();

  FileDownloadRequest(const FileDownloadRequest& from);

  inline FileDownloadRequest& operator=(const FileDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileDownloadRequest(FileDownloadRequest&& from) noexcept
    : FileDownloadRequest() {
    *this = ::std::move(from);
  }

  inline FileDownloadRequest& operator=(FileDownloadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const FileDownloadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileDownloadRequest* internal_default_instance() {
    return reinterpret_cast<const FileDownloadRequest*>(
               &_FileDownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FileDownloadRequest* other);
  friend void swap(FileDownloadRequest& a, FileDownloadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileDownloadRequest* New() const final {
    return CreateMaybeMessage<FileDownloadRequest>(NULL);
  }

  FileDownloadRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileDownloadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FileDownloadRequest& from);
  void MergeFrom(const FileDownloadRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileDownloadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:fileprotocol.FileDownloadRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileTransfer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.FileTransfer) */ {
 public:
  FileTransfer();
  virtual ~FileTransfer();

  FileTransfer(const FileTransfer& from);

  inline FileTransfer& operator=(const FileTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileTransfer(FileTransfer&& from) noexcept
    : FileTransfer() {
    *this = ::std::move(from);
  }

  inline FileTransfer& operator=(FileTransfer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const FileTransfer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileTransfer* internal_default_instance() {
    return reinterpret_cast<const FileTransfer*>(
               &_FileTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FileTransfer* other);
  friend void swap(FileTransfer& a, FileTransfer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileTransfer* New() const final {
    return CreateMaybeMessage<FileTransfer>(NULL);
  }

  FileTransfer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileTransfer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FileTransfer& from);
  void MergeFrom(const FileTransfer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileTransfer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filehash = 2;
  void clear_filehash();
  static const int kFilehashFieldNumber = 2;
  const ::std::string& filehash() const;
  void set_filehash(const ::std::string& value);
  #if LANG_CXX11
  void set_filehash(::std::string&& value);
  #endif
  void set_filehash(const char* value);
  void set_filehash(const char* value, size_t size);
  ::std::string* mutable_filehash();
  ::std::string* release_filehash();
  void set_allocated_filehash(::std::string* filehash);

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .fileprotocol.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::fileprotocol::Status status() const;
  void set_status(::fileprotocol::Status value);

  // fixed32 chunk_index = 3;
  void clear_chunk_index();
  static const int kChunkIndexFieldNumber = 3;
  ::google::protobuf::uint32 chunk_index() const;
  void set_chunk_index(::google::protobuf::uint32 value);

  // fixed64 data_len = 4;
  void clear_data_len();
  static const int kDataLenFieldNumber = 4;
  ::google::protobuf::uint64 data_len() const;
  void set_data_len(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fileprotocol.FileTransfer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filehash_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int status_;
  ::google::protobuf::uint32 chunk_index_;
  ::google::protobuf::uint64 data_len_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusUpdate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.StatusUpdate) */ {
 public:
  StatusUpdate();
  virtual ~StatusUpdate();

  StatusUpdate(const StatusUpdate& from);

  inline StatusUpdate& operator=(const StatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusUpdate(StatusUpdate&& from) noexcept
    : StatusUpdate() {
    *this = ::std::move(from);
  }

  inline StatusUpdate& operator=(StatusUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const StatusUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusUpdate* internal_default_instance() {
    return reinterpret_cast<const StatusUpdate*>(
               &_StatusUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(StatusUpdate* other);
  friend void swap(StatusUpdate& a, StatusUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusUpdate* New() const final {
    return CreateMaybeMessage<StatusUpdate>(NULL);
  }

  StatusUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const StatusUpdate& from);
  void MergeFrom(const StatusUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatusUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fileprotocol.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::fileprotocol::Status status() const;
  void set_status(::fileprotocol::Status value);

  // fixed32 need_chunk_index = 2;
  void clear_need_chunk_index();
  static const int kNeedChunkIndexFieldNumber = 2;
  ::google::protobuf::uint32 need_chunk_index() const;
  void set_need_chunk_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fileprotocol.StatusUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int status_;
  ::google::protobuf::uint32 need_chunk_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgHeader : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.MsgHeader) */ {
 public:
  MsgHeader();
  virtual ~MsgHeader();

  MsgHeader(const MsgHeader& from);

  inline MsgHeader& operator=(const MsgHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgHeader(MsgHeader&& from) noexcept
    : MsgHeader() {
    *this = ::std::move(from);
  }

  inline MsgHeader& operator=(MsgHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const MsgHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgHeader* internal_default_instance() {
    return reinterpret_cast<const MsgHeader*>(
               &_MsgHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MsgHeader* other);
  friend void swap(MsgHeader& a, MsgHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgHeader* New() const final {
    return CreateMaybeMessage<MsgHeader>(NULL);
  }

  MsgHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MsgHeader& from);
  void MergeFrom(const MsgHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed32 magic = 1;
  void clear_magic();
  static const int kMagicFieldNumber = 1;
  ::google::protobuf::uint32 magic() const;
  void set_magic(::google::protobuf::uint32 value);

  // fixed32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // fixed32 length = 3;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // fixed32 session_id = 4;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // .fileprotocol.MsgType type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::fileprotocol::MsgType type() const;
  void set_type(::fileprotocol::MsgType value);

  // @@protoc_insertion_point(class_scope:fileprotocol.MsgHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 magic_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 session_id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgBody : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:fileprotocol.MsgBody) */ {
 public:
  MsgBody();
  virtual ~MsgBody();

  MsgBody(const MsgBody& from);

  inline MsgBody& operator=(const MsgBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgBody(MsgBody&& from) noexcept
    : MsgBody() {
    *this = ::std::move(from);
  }

  inline MsgBody& operator=(MsgBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const MsgBody& default_instance();

  enum BodyCase {
    kBrowseResponse = 1,
    kFileSummary = 2,
    kFileDownloadRequest = 3,
    kFileTransfer = 4,
    kStatusUpdate = 5,
    kAuthRequest = 6,
    kAuthResponse = 7,
    BODY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgBody* internal_default_instance() {
    return reinterpret_cast<const MsgBody*>(
               &_MsgBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MsgBody* other);
  friend void swap(MsgBody& a, MsgBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgBody* New() const final {
    return CreateMaybeMessage<MsgBody>(NULL);
  }

  MsgBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgBody>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MsgBody& from);
  void MergeFrom(const MsgBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fileprotocol.BrowseResponse browse_response = 1;
  bool has_browse_response() const;
  void clear_browse_response();
  static const int kBrowseResponseFieldNumber = 1;
  private:
  const ::fileprotocol::BrowseResponse& _internal_browse_response() const;
  public:
  const ::fileprotocol::BrowseResponse& browse_response() const;
  ::fileprotocol::BrowseResponse* release_browse_response();
  ::fileprotocol::BrowseResponse* mutable_browse_response();
  void set_allocated_browse_response(::fileprotocol::BrowseResponse* browse_response);

  // .fileprotocol.FileSummary file_summary = 2;
  bool has_file_summary() const;
  void clear_file_summary();
  static const int kFileSummaryFieldNumber = 2;
  private:
  const ::fileprotocol::FileSummary& _internal_file_summary() const;
  public:
  const ::fileprotocol::FileSummary& file_summary() const;
  ::fileprotocol::FileSummary* release_file_summary();
  ::fileprotocol::FileSummary* mutable_file_summary();
  void set_allocated_file_summary(::fileprotocol::FileSummary* file_summary);

  // .fileprotocol.FileDownloadRequest file_download_request = 3;
  bool has_file_download_request() const;
  void clear_file_download_request();
  static const int kFileDownloadRequestFieldNumber = 3;
  private:
  const ::fileprotocol::FileDownloadRequest& _internal_file_download_request() const;
  public:
  const ::fileprotocol::FileDownloadRequest& file_download_request() const;
  ::fileprotocol::FileDownloadRequest* release_file_download_request();
  ::fileprotocol::FileDownloadRequest* mutable_file_download_request();
  void set_allocated_file_download_request(::fileprotocol::FileDownloadRequest* file_download_request);

  // .fileprotocol.FileTransfer file_transfer = 4;
  bool has_file_transfer() const;
  void clear_file_transfer();
  static const int kFileTransferFieldNumber = 4;
  private:
  const ::fileprotocol::FileTransfer& _internal_file_transfer() const;
  public:
  const ::fileprotocol::FileTransfer& file_transfer() const;
  ::fileprotocol::FileTransfer* release_file_transfer();
  ::fileprotocol::FileTransfer* mutable_file_transfer();
  void set_allocated_file_transfer(::fileprotocol::FileTransfer* file_transfer);

  // .fileprotocol.StatusUpdate status_update = 5;
  bool has_status_update() const;
  void clear_status_update();
  static const int kStatusUpdateFieldNumber = 5;
  private:
  const ::fileprotocol::StatusUpdate& _internal_status_update() const;
  public:
  const ::fileprotocol::StatusUpdate& status_update() const;
  ::fileprotocol::StatusUpdate* release_status_update();
  ::fileprotocol::StatusUpdate* mutable_status_update();
  void set_allocated_status_update(::fileprotocol::StatusUpdate* status_update);

  // .fileprotocol.AuthRequest auth_request = 6;
  bool has_auth_request() const;
  void clear_auth_request();
  static const int kAuthRequestFieldNumber = 6;
  private:
  const ::fileprotocol::AuthRequest& _internal_auth_request() const;
  public:
  const ::fileprotocol::AuthRequest& auth_request() const;
  ::fileprotocol::AuthRequest* release_auth_request();
  ::fileprotocol::AuthRequest* mutable_auth_request();
  void set_allocated_auth_request(::fileprotocol::AuthRequest* auth_request);

  // .fileprotocol.AuthResponse auth_response = 7;
  bool has_auth_response() const;
  void clear_auth_response();
  static const int kAuthResponseFieldNumber = 7;
  private:
  const ::fileprotocol::AuthResponse& _internal_auth_response() const;
  public:
  const ::fileprotocol::AuthResponse& auth_response() const;
  ::fileprotocol::AuthResponse* release_auth_response();
  ::fileprotocol::AuthResponse* mutable_auth_response();
  void set_allocated_auth_response(::fileprotocol::AuthResponse* auth_response);

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:fileprotocol.MsgBody)
 private:
  void set_has_browse_response();
  void set_has_file_summary();
  void set_has_file_download_request();
  void set_has_file_transfer();
  void set_has_status_update();
  void set_has_auth_request();
  void set_has_auth_response();

  inline bool has_body() const;
  inline void clear_has_body();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union BodyUnion {
    BodyUnion() {}
    ::fileprotocol::BrowseResponse* browse_response_;
    ::fileprotocol::FileSummary* file_summary_;
    ::fileprotocol::FileDownloadRequest* file_download_request_;
    ::fileprotocol::FileTransfer* file_transfer_;
    ::fileprotocol::StatusUpdate* status_update_;
    ::fileprotocol::AuthRequest* auth_request_;
    ::fileprotocol::AuthResponse* auth_response_;
  } body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuthRequest

// .fileprotocol.AuthRequestState auth_request_state = 1;
inline void AuthRequest::clear_auth_request_state() {
  auth_request_state_ = 0;
}
inline ::fileprotocol::AuthRequestState AuthRequest::auth_request_state() const {
  // @@protoc_insertion_point(field_get:fileprotocol.AuthRequest.auth_request_state)
  return static_cast< ::fileprotocol::AuthRequestState >(auth_request_state_);
}
inline void AuthRequest::set_auth_request_state(::fileprotocol::AuthRequestState value) {
  
  auth_request_state_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.AuthRequest.auth_request_state)
}

// string username = 2;
inline void AuthRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthRequest::username() const {
  // @@protoc_insertion_point(field_get:fileprotocol.AuthRequest.username)
  return username_.GetNoArena();
}
inline void AuthRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.AuthRequest.username)
}
#if LANG_CXX11
inline void AuthRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.AuthRequest.username)
}
#endif
inline void AuthRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.AuthRequest.username)
}
inline void AuthRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.AuthRequest.username)
}
inline ::std::string* AuthRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.AuthRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthRequest::release_username() {
  // @@protoc_insertion_point(field_release:fileprotocol.AuthRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.AuthRequest.username)
}

// string passwd = 3;
inline void AuthRequest::clear_passwd() {
  passwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthRequest::passwd() const {
  // @@protoc_insertion_point(field_get:fileprotocol.AuthRequest.passwd)
  return passwd_.GetNoArena();
}
inline void AuthRequest::set_passwd(const ::std::string& value) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.AuthRequest.passwd)
}
#if LANG_CXX11
inline void AuthRequest::set_passwd(::std::string&& value) {
  
  passwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.AuthRequest.passwd)
}
#endif
inline void AuthRequest::set_passwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.AuthRequest.passwd)
}
inline void AuthRequest::set_passwd(const char* value, size_t size) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.AuthRequest.passwd)
}
inline ::std::string* AuthRequest::mutable_passwd() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.AuthRequest.passwd)
  return passwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthRequest::release_passwd() {
  // @@protoc_insertion_point(field_release:fileprotocol.AuthRequest.passwd)
  
  return passwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthRequest::set_allocated_passwd(::std::string* passwd) {
  if (passwd != NULL) {
    
  } else {
    
  }
  passwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passwd);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.AuthRequest.passwd)
}

// -------------------------------------------------------------------

// AuthResponse

// .fileprotocol.AuthResponseState auth_response_state = 1;
inline void AuthResponse::clear_auth_response_state() {
  auth_response_state_ = 0;
}
inline ::fileprotocol::AuthResponseState AuthResponse::auth_response_state() const {
  // @@protoc_insertion_point(field_get:fileprotocol.AuthResponse.auth_response_state)
  return static_cast< ::fileprotocol::AuthResponseState >(auth_response_state_);
}
inline void AuthResponse::set_auth_response_state(::fileprotocol::AuthResponseState value) {
  
  auth_response_state_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.AuthResponse.auth_response_state)
}

// -------------------------------------------------------------------

// BrowseResponse

// repeated string filenames = 1;
inline int BrowseResponse::filenames_size() const {
  return filenames_.size();
}
inline void BrowseResponse::clear_filenames() {
  filenames_.Clear();
}
inline const ::std::string& BrowseResponse::filenames(int index) const {
  // @@protoc_insertion_point(field_get:fileprotocol.BrowseResponse.filenames)
  return filenames_.Get(index);
}
inline ::std::string* BrowseResponse::mutable_filenames(int index) {
  // @@protoc_insertion_point(field_mutable:fileprotocol.BrowseResponse.filenames)
  return filenames_.Mutable(index);
}
inline void BrowseResponse::set_filenames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fileprotocol.BrowseResponse.filenames)
  filenames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BrowseResponse::set_filenames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fileprotocol.BrowseResponse.filenames)
  filenames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BrowseResponse::set_filenames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fileprotocol.BrowseResponse.filenames)
}
inline void BrowseResponse::set_filenames(int index, const char* value, size_t size) {
  filenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.BrowseResponse.filenames)
}
inline ::std::string* BrowseResponse::add_filenames() {
  // @@protoc_insertion_point(field_add_mutable:fileprotocol.BrowseResponse.filenames)
  return filenames_.Add();
}
inline void BrowseResponse::add_filenames(const ::std::string& value) {
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fileprotocol.BrowseResponse.filenames)
}
#if LANG_CXX11
inline void BrowseResponse::add_filenames(::std::string&& value) {
  filenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fileprotocol.BrowseResponse.filenames)
}
#endif
inline void BrowseResponse::add_filenames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fileprotocol.BrowseResponse.filenames)
}
inline void BrowseResponse::add_filenames(const char* value, size_t size) {
  filenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fileprotocol.BrowseResponse.filenames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BrowseResponse::filenames() const {
  // @@protoc_insertion_point(field_list:fileprotocol.BrowseResponse.filenames)
  return filenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BrowseResponse::mutable_filenames() {
  // @@protoc_insertion_point(field_mutable_list:fileprotocol.BrowseResponse.filenames)
  return &filenames_;
}

// -------------------------------------------------------------------

// FileSummary

// string filename = 1;
inline void FileSummary::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileSummary::filename() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileSummary.filename)
  return filename_.GetNoArena();
}
inline void FileSummary::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.FileSummary.filename)
}
#if LANG_CXX11
inline void FileSummary::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.FileSummary.filename)
}
#endif
inline void FileSummary::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.FileSummary.filename)
}
inline void FileSummary::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.FileSummary.filename)
}
inline ::std::string* FileSummary::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.FileSummary.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileSummary::release_filename() {
  // @@protoc_insertion_point(field_release:fileprotocol.FileSummary.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileSummary::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.FileSummary.filename)
}

// string format = 2;
inline void FileSummary::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileSummary::format() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileSummary.format)
  return format_.GetNoArena();
}
inline void FileSummary::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.FileSummary.format)
}
#if LANG_CXX11
inline void FileSummary::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.FileSummary.format)
}
#endif
inline void FileSummary::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.FileSummary.format)
}
inline void FileSummary::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.FileSummary.format)
}
inline ::std::string* FileSummary::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.FileSummary.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileSummary::release_format() {
  // @@protoc_insertion_point(field_release:fileprotocol.FileSummary.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileSummary::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.FileSummary.format)
}

// string filehash = 3;
inline void FileSummary::clear_filehash() {
  filehash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileSummary::filehash() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileSummary.filehash)
  return filehash_.GetNoArena();
}
inline void FileSummary::set_filehash(const ::std::string& value) {
  
  filehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.FileSummary.filehash)
}
#if LANG_CXX11
inline void FileSummary::set_filehash(::std::string&& value) {
  
  filehash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.FileSummary.filehash)
}
#endif
inline void FileSummary::set_filehash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.FileSummary.filehash)
}
inline void FileSummary::set_filehash(const char* value, size_t size) {
  
  filehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.FileSummary.filehash)
}
inline ::std::string* FileSummary::mutable_filehash() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.FileSummary.filehash)
  return filehash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileSummary::release_filehash() {
  // @@protoc_insertion_point(field_release:fileprotocol.FileSummary.filehash)
  
  return filehash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileSummary::set_allocated_filehash(::std::string* filehash) {
  if (filehash != NULL) {
    
  } else {
    
  }
  filehash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filehash);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.FileSummary.filehash)
}

// fixed64 filesize = 4;
inline void FileSummary::clear_filesize() {
  filesize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FileSummary::filesize() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileSummary.filesize)
  return filesize_;
}
inline void FileSummary::set_filesize(::google::protobuf::uint64 value) {
  
  filesize_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.FileSummary.filesize)
}

// fixed32 total_chunk = 5;
inline void FileSummary::clear_total_chunk() {
  total_chunk_ = 0u;
}
inline ::google::protobuf::uint32 FileSummary::total_chunk() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileSummary.total_chunk)
  return total_chunk_;
}
inline void FileSummary::set_total_chunk(::google::protobuf::uint32 value) {
  
  total_chunk_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.FileSummary.total_chunk)
}

// -------------------------------------------------------------------

// FileDownloadRequest

// string filename = 1;
inline void FileDownloadRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileDownloadRequest::filename() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileDownloadRequest.filename)
  return filename_.GetNoArena();
}
inline void FileDownloadRequest::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.FileDownloadRequest.filename)
}
#if LANG_CXX11
inline void FileDownloadRequest::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.FileDownloadRequest.filename)
}
#endif
inline void FileDownloadRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.FileDownloadRequest.filename)
}
inline void FileDownloadRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.FileDownloadRequest.filename)
}
inline ::std::string* FileDownloadRequest::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.FileDownloadRequest.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDownloadRequest::release_filename() {
  // @@protoc_insertion_point(field_release:fileprotocol.FileDownloadRequest.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDownloadRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.FileDownloadRequest.filename)
}

// -------------------------------------------------------------------

// FileTransfer

// .fileprotocol.Status status = 1;
inline void FileTransfer::clear_status() {
  status_ = 0;
}
inline ::fileprotocol::Status FileTransfer::status() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileTransfer.status)
  return static_cast< ::fileprotocol::Status >(status_);
}
inline void FileTransfer::set_status(::fileprotocol::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.FileTransfer.status)
}

// string filehash = 2;
inline void FileTransfer::clear_filehash() {
  filehash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransfer::filehash() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileTransfer.filehash)
  return filehash_.GetNoArena();
}
inline void FileTransfer::set_filehash(const ::std::string& value) {
  
  filehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.FileTransfer.filehash)
}
#if LANG_CXX11
inline void FileTransfer::set_filehash(::std::string&& value) {
  
  filehash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.FileTransfer.filehash)
}
#endif
inline void FileTransfer::set_filehash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.FileTransfer.filehash)
}
inline void FileTransfer::set_filehash(const char* value, size_t size) {
  
  filehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.FileTransfer.filehash)
}
inline ::std::string* FileTransfer::mutable_filehash() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.FileTransfer.filehash)
  return filehash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransfer::release_filehash() {
  // @@protoc_insertion_point(field_release:fileprotocol.FileTransfer.filehash)
  
  return filehash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransfer::set_allocated_filehash(::std::string* filehash) {
  if (filehash != NULL) {
    
  } else {
    
  }
  filehash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filehash);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.FileTransfer.filehash)
}

// fixed32 chunk_index = 3;
inline void FileTransfer::clear_chunk_index() {
  chunk_index_ = 0u;
}
inline ::google::protobuf::uint32 FileTransfer::chunk_index() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileTransfer.chunk_index)
  return chunk_index_;
}
inline void FileTransfer::set_chunk_index(::google::protobuf::uint32 value) {
  
  chunk_index_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.FileTransfer.chunk_index)
}

// fixed64 data_len = 4;
inline void FileTransfer::clear_data_len() {
  data_len_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FileTransfer::data_len() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileTransfer.data_len)
  return data_len_;
}
inline void FileTransfer::set_data_len(::google::protobuf::uint64 value) {
  
  data_len_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.FileTransfer.data_len)
}

// bytes data = 5;
inline void FileTransfer::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTransfer::data() const {
  // @@protoc_insertion_point(field_get:fileprotocol.FileTransfer.data)
  return data_.GetNoArena();
}
inline void FileTransfer::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fileprotocol.FileTransfer.data)
}
#if LANG_CXX11
inline void FileTransfer::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fileprotocol.FileTransfer.data)
}
#endif
inline void FileTransfer::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fileprotocol.FileTransfer.data)
}
inline void FileTransfer::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fileprotocol.FileTransfer.data)
}
inline ::std::string* FileTransfer::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:fileprotocol.FileTransfer.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTransfer::release_data() {
  // @@protoc_insertion_point(field_release:fileprotocol.FileTransfer.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTransfer::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:fileprotocol.FileTransfer.data)
}

// -------------------------------------------------------------------

// StatusUpdate

// .fileprotocol.Status status = 1;
inline void StatusUpdate::clear_status() {
  status_ = 0;
}
inline ::fileprotocol::Status StatusUpdate::status() const {
  // @@protoc_insertion_point(field_get:fileprotocol.StatusUpdate.status)
  return static_cast< ::fileprotocol::Status >(status_);
}
inline void StatusUpdate::set_status(::fileprotocol::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.StatusUpdate.status)
}

// fixed32 need_chunk_index = 2;
inline void StatusUpdate::clear_need_chunk_index() {
  need_chunk_index_ = 0u;
}
inline ::google::protobuf::uint32 StatusUpdate::need_chunk_index() const {
  // @@protoc_insertion_point(field_get:fileprotocol.StatusUpdate.need_chunk_index)
  return need_chunk_index_;
}
inline void StatusUpdate::set_need_chunk_index(::google::protobuf::uint32 value) {
  
  need_chunk_index_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.StatusUpdate.need_chunk_index)
}

// -------------------------------------------------------------------

// MsgHeader

// fixed32 magic = 1;
inline void MsgHeader::clear_magic() {
  magic_ = 0u;
}
inline ::google::protobuf::uint32 MsgHeader::magic() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgHeader.magic)
  return magic_;
}
inline void MsgHeader::set_magic(::google::protobuf::uint32 value) {
  
  magic_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.MsgHeader.magic)
}

// fixed32 version = 2;
inline void MsgHeader::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 MsgHeader::version() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgHeader.version)
  return version_;
}
inline void MsgHeader::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.MsgHeader.version)
}

// fixed32 length = 3;
inline void MsgHeader::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 MsgHeader::length() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgHeader.length)
  return length_;
}
inline void MsgHeader::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.MsgHeader.length)
}

// fixed32 session_id = 4;
inline void MsgHeader::clear_session_id() {
  session_id_ = 0u;
}
inline ::google::protobuf::uint32 MsgHeader::session_id() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgHeader.session_id)
  return session_id_;
}
inline void MsgHeader::set_session_id(::google::protobuf::uint32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.MsgHeader.session_id)
}

// .fileprotocol.MsgType type = 5;
inline void MsgHeader::clear_type() {
  type_ = 0;
}
inline ::fileprotocol::MsgType MsgHeader::type() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgHeader.type)
  return static_cast< ::fileprotocol::MsgType >(type_);
}
inline void MsgHeader::set_type(::fileprotocol::MsgType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fileprotocol.MsgHeader.type)
}

// -------------------------------------------------------------------

// MsgBody

// .fileprotocol.BrowseResponse browse_response = 1;
inline bool MsgBody::has_browse_response() const {
  return body_case() == kBrowseResponse;
}
inline void MsgBody::set_has_browse_response() {
  _oneof_case_[0] = kBrowseResponse;
}
inline void MsgBody::clear_browse_response() {
  if (has_browse_response()) {
    delete body_.browse_response_;
    clear_has_body();
  }
}
inline const ::fileprotocol::BrowseResponse& MsgBody::_internal_browse_response() const {
  return *body_.browse_response_;
}
inline ::fileprotocol::BrowseResponse* MsgBody::release_browse_response() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.browse_response)
  if (has_browse_response()) {
    clear_has_body();
      ::fileprotocol::BrowseResponse* temp = body_.browse_response_;
    body_.browse_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::BrowseResponse& MsgBody::browse_response() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.browse_response)
  return has_browse_response()
      ? *body_.browse_response_
      : *reinterpret_cast< ::fileprotocol::BrowseResponse*>(&::fileprotocol::_BrowseResponse_default_instance_);
}
inline ::fileprotocol::BrowseResponse* MsgBody::mutable_browse_response() {
  if (!has_browse_response()) {
    clear_body();
    set_has_browse_response();
    body_.browse_response_ = CreateMaybeMessage< ::fileprotocol::BrowseResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.browse_response)
  return body_.browse_response_;
}

// .fileprotocol.FileSummary file_summary = 2;
inline bool MsgBody::has_file_summary() const {
  return body_case() == kFileSummary;
}
inline void MsgBody::set_has_file_summary() {
  _oneof_case_[0] = kFileSummary;
}
inline void MsgBody::clear_file_summary() {
  if (has_file_summary()) {
    delete body_.file_summary_;
    clear_has_body();
  }
}
inline const ::fileprotocol::FileSummary& MsgBody::_internal_file_summary() const {
  return *body_.file_summary_;
}
inline ::fileprotocol::FileSummary* MsgBody::release_file_summary() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.file_summary)
  if (has_file_summary()) {
    clear_has_body();
      ::fileprotocol::FileSummary* temp = body_.file_summary_;
    body_.file_summary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::FileSummary& MsgBody::file_summary() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.file_summary)
  return has_file_summary()
      ? *body_.file_summary_
      : *reinterpret_cast< ::fileprotocol::FileSummary*>(&::fileprotocol::_FileSummary_default_instance_);
}
inline ::fileprotocol::FileSummary* MsgBody::mutable_file_summary() {
  if (!has_file_summary()) {
    clear_body();
    set_has_file_summary();
    body_.file_summary_ = CreateMaybeMessage< ::fileprotocol::FileSummary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.file_summary)
  return body_.file_summary_;
}

// .fileprotocol.FileDownloadRequest file_download_request = 3;
inline bool MsgBody::has_file_download_request() const {
  return body_case() == kFileDownloadRequest;
}
inline void MsgBody::set_has_file_download_request() {
  _oneof_case_[0] = kFileDownloadRequest;
}
inline void MsgBody::clear_file_download_request() {
  if (has_file_download_request()) {
    delete body_.file_download_request_;
    clear_has_body();
  }
}
inline const ::fileprotocol::FileDownloadRequest& MsgBody::_internal_file_download_request() const {
  return *body_.file_download_request_;
}
inline ::fileprotocol::FileDownloadRequest* MsgBody::release_file_download_request() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.file_download_request)
  if (has_file_download_request()) {
    clear_has_body();
      ::fileprotocol::FileDownloadRequest* temp = body_.file_download_request_;
    body_.file_download_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::FileDownloadRequest& MsgBody::file_download_request() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.file_download_request)
  return has_file_download_request()
      ? *body_.file_download_request_
      : *reinterpret_cast< ::fileprotocol::FileDownloadRequest*>(&::fileprotocol::_FileDownloadRequest_default_instance_);
}
inline ::fileprotocol::FileDownloadRequest* MsgBody::mutable_file_download_request() {
  if (!has_file_download_request()) {
    clear_body();
    set_has_file_download_request();
    body_.file_download_request_ = CreateMaybeMessage< ::fileprotocol::FileDownloadRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.file_download_request)
  return body_.file_download_request_;
}

// .fileprotocol.FileTransfer file_transfer = 4;
inline bool MsgBody::has_file_transfer() const {
  return body_case() == kFileTransfer;
}
inline void MsgBody::set_has_file_transfer() {
  _oneof_case_[0] = kFileTransfer;
}
inline void MsgBody::clear_file_transfer() {
  if (has_file_transfer()) {
    delete body_.file_transfer_;
    clear_has_body();
  }
}
inline const ::fileprotocol::FileTransfer& MsgBody::_internal_file_transfer() const {
  return *body_.file_transfer_;
}
inline ::fileprotocol::FileTransfer* MsgBody::release_file_transfer() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.file_transfer)
  if (has_file_transfer()) {
    clear_has_body();
      ::fileprotocol::FileTransfer* temp = body_.file_transfer_;
    body_.file_transfer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::FileTransfer& MsgBody::file_transfer() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.file_transfer)
  return has_file_transfer()
      ? *body_.file_transfer_
      : *reinterpret_cast< ::fileprotocol::FileTransfer*>(&::fileprotocol::_FileTransfer_default_instance_);
}
inline ::fileprotocol::FileTransfer* MsgBody::mutable_file_transfer() {
  if (!has_file_transfer()) {
    clear_body();
    set_has_file_transfer();
    body_.file_transfer_ = CreateMaybeMessage< ::fileprotocol::FileTransfer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.file_transfer)
  return body_.file_transfer_;
}

// .fileprotocol.StatusUpdate status_update = 5;
inline bool MsgBody::has_status_update() const {
  return body_case() == kStatusUpdate;
}
inline void MsgBody::set_has_status_update() {
  _oneof_case_[0] = kStatusUpdate;
}
inline void MsgBody::clear_status_update() {
  if (has_status_update()) {
    delete body_.status_update_;
    clear_has_body();
  }
}
inline const ::fileprotocol::StatusUpdate& MsgBody::_internal_status_update() const {
  return *body_.status_update_;
}
inline ::fileprotocol::StatusUpdate* MsgBody::release_status_update() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.status_update)
  if (has_status_update()) {
    clear_has_body();
      ::fileprotocol::StatusUpdate* temp = body_.status_update_;
    body_.status_update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::StatusUpdate& MsgBody::status_update() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.status_update)
  return has_status_update()
      ? *body_.status_update_
      : *reinterpret_cast< ::fileprotocol::StatusUpdate*>(&::fileprotocol::_StatusUpdate_default_instance_);
}
inline ::fileprotocol::StatusUpdate* MsgBody::mutable_status_update() {
  if (!has_status_update()) {
    clear_body();
    set_has_status_update();
    body_.status_update_ = CreateMaybeMessage< ::fileprotocol::StatusUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.status_update)
  return body_.status_update_;
}

// .fileprotocol.AuthRequest auth_request = 6;
inline bool MsgBody::has_auth_request() const {
  return body_case() == kAuthRequest;
}
inline void MsgBody::set_has_auth_request() {
  _oneof_case_[0] = kAuthRequest;
}
inline void MsgBody::clear_auth_request() {
  if (has_auth_request()) {
    delete body_.auth_request_;
    clear_has_body();
  }
}
inline const ::fileprotocol::AuthRequest& MsgBody::_internal_auth_request() const {
  return *body_.auth_request_;
}
inline ::fileprotocol::AuthRequest* MsgBody::release_auth_request() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.auth_request)
  if (has_auth_request()) {
    clear_has_body();
      ::fileprotocol::AuthRequest* temp = body_.auth_request_;
    body_.auth_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::AuthRequest& MsgBody::auth_request() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.auth_request)
  return has_auth_request()
      ? *body_.auth_request_
      : *reinterpret_cast< ::fileprotocol::AuthRequest*>(&::fileprotocol::_AuthRequest_default_instance_);
}
inline ::fileprotocol::AuthRequest* MsgBody::mutable_auth_request() {
  if (!has_auth_request()) {
    clear_body();
    set_has_auth_request();
    body_.auth_request_ = CreateMaybeMessage< ::fileprotocol::AuthRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.auth_request)
  return body_.auth_request_;
}

// .fileprotocol.AuthResponse auth_response = 7;
inline bool MsgBody::has_auth_response() const {
  return body_case() == kAuthResponse;
}
inline void MsgBody::set_has_auth_response() {
  _oneof_case_[0] = kAuthResponse;
}
inline void MsgBody::clear_auth_response() {
  if (has_auth_response()) {
    delete body_.auth_response_;
    clear_has_body();
  }
}
inline const ::fileprotocol::AuthResponse& MsgBody::_internal_auth_response() const {
  return *body_.auth_response_;
}
inline ::fileprotocol::AuthResponse* MsgBody::release_auth_response() {
  // @@protoc_insertion_point(field_release:fileprotocol.MsgBody.auth_response)
  if (has_auth_response()) {
    clear_has_body();
      ::fileprotocol::AuthResponse* temp = body_.auth_response_;
    body_.auth_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::fileprotocol::AuthResponse& MsgBody::auth_response() const {
  // @@protoc_insertion_point(field_get:fileprotocol.MsgBody.auth_response)
  return has_auth_response()
      ? *body_.auth_response_
      : *reinterpret_cast< ::fileprotocol::AuthResponse*>(&::fileprotocol::_AuthResponse_default_instance_);
}
inline ::fileprotocol::AuthResponse* MsgBody::mutable_auth_response() {
  if (!has_auth_response()) {
    clear_body();
    set_has_auth_response();
    body_.auth_response_ = CreateMaybeMessage< ::fileprotocol::AuthResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:fileprotocol.MsgBody.auth_response)
  return body_.auth_response_;
}

inline bool MsgBody::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void MsgBody::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline MsgBody::BodyCase MsgBody::body_case() const {
  return MsgBody::BodyCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fileprotocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fileprotocol::Status> : ::std::true_type {};
template <> struct is_proto_enum< ::fileprotocol::MsgType> : ::std::true_type {};
template <> struct is_proto_enum< ::fileprotocol::AuthRequestState> : ::std::true_type {};
template <> struct is_proto_enum< ::fileprotocol::AuthResponseState> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2eproto
